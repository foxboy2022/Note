function Promise(executor) {
  const STATUS = {
    PENDING: 'pending',
    FULFILLED: 'fulfilled',
    REJECTED: 'rejected'
  };

  let status = STATUS.PENDING;
  let result = undefined;
  let successCallback = [];
  let errorCallback = [];

  function resolve(value) {
    if (status === STATUS.PENDING) {
      status = STATUS.FULFILLED;
      result = value;
      setTimeout(() => {
        successCallback.forEach(callback => callback(result));
      });
    }
  }

  function reject(reason) {
    if (status === STATUS.PENDING) {
      status = STATUS.REJECTED;
      result = reason;
      setTimeout(() => {
        errorCallback.forEach(callback => callback(result));
      });
    }
  }

  this.then = function(onFulfilled, onRejected) {
    return new Promise((resolve, reject) => {
      function handleSuccess(value) {
        if (typeof onFulfilled === 'function') {
          try {
            const res = onFulfilled(value);
            resolve(res);
          } catch (error) {
            reject(error);
          }
        } else {
          resolve(value);
        }
      }

      function handleFailure(reason) {
        if (typeof onRejected === 'function') {
          try {
            const res = onRejected(reason);
            resolve(res);
          } catch (error) {
            reject(error);
          }
        } else {
          reject(reason);
        }
      }

      switch (status) {
        case STATUS.PENDING:
          successCallback.push(handleSuccess);
          errorCallback.push(handleFailure);
          break;
        case STATUS.FULFILLED:
          setTimeout(() => handleSuccess(result));
          break;
        case STATUS.REJECTED:
          setTimeout(() => handleFailure(result));
          break;
      }
    });
  };

  executor(resolve, reject);
}
